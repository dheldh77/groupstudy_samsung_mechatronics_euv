# 8. EC2 서버에 프로젝트를 배포해 보자

## 1. EC2에 프로젝트 Clone 받기

```bash
sudo yum install git # 깃 설치
```

```bash
git --version # 깃 버전 체크
```

```bash
mkdir ~/app && mkdir ~/app/step1 # git clone으로 프로젝트 저장할 디렉토리 생성
cd ~/app/step1 # 생성된 디렉토리 이동
git clone [github repository https 주소] # 복사한 https 주소를 통해 git clone
```

```bash
cd 프로젝트 명 # git clone 한 디렉토리로 이동
ll # 파일 확인

./gradlew test # git clone해서 가져온 코드들이 잘 수행되는지 테스트로 검증
```

만약 다음과 같이 에러 메시지가 뜬다면

```bash
-bash: ./gradlew: Permission denied
```

```bash
chmod +x ./gradlew # 실행 권한 추가
```

> 현재 EC2 서버에는 Gradle을 설치하지 않았지만 Gradle Task(ex: test)를 수행할 수 있는 이유는 프로젝트 내부에 포함된 `gradlew` 때문이다. **Gradle이 설치되지 않은 환경 혹은 버전에서도 Gradle을 쓸 수 있도록 지원하는 Wrapper 파일** 이다. 해당 파일을 직접 이용하기 때문에 Gradle을 별도로 설치할 필요가 없다.
> 

## 2. 배포 스크립트 만들기

### 배포란?

작성한 코드를 실제 서버에 반영하는 것

- git clone 혹은 git pull을 통해 새 버전의 프로젝트를 받음
- Gradle이나 Maven을 통해 프로젝트 테스트와 빌드
- EC2 서버에서 해당 프로젝트 실행 및 재실행

```bash
vim ~/app/step1/deploy.sh # 배포를 위한 스크립트 작성
```

```bash
#!/bin/bash

REPOSITORY=/home/ec2-user/app/step1
PROJECT_NAME=springboot2-webservice

cd $REPOSITORY/$PROJECT_NAME

echo "> Git Pull" # echo는 문자열을 출력하는 명령어

git pull

echo "> 프로젝트 Build 시작"

./gradlew build # 프로젝트 내부의 gradlew로 build 수행

echo "> step1 디렉토리로 이동"

cd $REPOSITORY

echo "> Build 파일 복사"

# build 결과물인 jar 파일을 복사해 jar파일을 모아둔 위치로 복사합니다.
cp $REPOSITORY/$PROJECT_NAME/build/libs/*.jar $REPOSITORY/

echo "> 현재 구동중인 애플리케이션 pid 확인"

# pgrep은 process id만 추출하는 명령어 입니다.
# -f 옵션은 프로세스 이름으로 찾습니다.
CURRENT_PID=$(pgrep -f ${PROJECT_NAME}.*.jar)

echo "현재 구동 중인 애플리케이션 pid: $CURRENT_PID"

# 현재 구동중인 프로세스를 pid로 찾아 해당 프로세스 종료
if [ -z "$CURRENT_PID" ]; then
	echo "> 현재 구동 중인 애플리케이션이 없으므로 종료하지 않습니다."
else
	echo "> kill -15 &CURRENT_PID"
	kill -15 $CURRENT_PID
	sleep 5
fi

echo "> 새 애플리케이션 배포"

# 새로 실행할 jar 파일 명을 찾습니다.
# 여러 jar 파일이 생기기 때문에 tail -n로 가장 나중의 jar 파일을 변수에 저장합니다.
JAR_NAME=$(ls -tr $REPOSITORY/ | grep jar | tail -n 1)

echo "> JAR Name: $JAR_NAME"

# 찾은 jar 파일명으로 해당 jar 파일을 nohup으로 실행합니다.
# 스프링 부트의 장점은 외장 톰캣을 설치할 필요가 없다는 점입니다.
# 내장 톰캣을 사용해 jar 파일만 있으면 바로 웹 애플리케이션 서버를 실행할 수 있습니다.
# 일반적으로 자바를 실행할 때는 java -jar라는 명령어를 사용하지만, 이렇게 하면 사용자가 터미널 접속을 끊을 때 애플리케이션도 같이 종료됩니다.
# 애플리케이션 실행자가 터미널을 종료해도 애플리케이션이 계속 구동될 수 있도록 nohup 명령어를 사용합니다.
nohup java -jar $REPOSITORY/$JAR_NAME 2>$1 &

# > : 리다이렉트
# 2 : 표준 에러 출력을 뜻하는 디스크립터(예약어)
# & : 파일 스크립트(출력)를 뜻하는 기호
# 1 : 표준 출력을 뜻하는 디스크립터
# 2>&1 &: 에러 출력을 리다이렉트 해라 표준 출력으로 (nohup.out에 기록) 그리고 deploy.sh에 작성한 내용 출력해라
```

```bash
chmod +x ./deploy.sh # 생성한 deploy.sh에 실행 권한 추가
```

```bash
./deploy.sh # 스크립트 실행
...
vim nohup.out # 애플리케이션 출력 내용 확인, Fail이 난 이유는 appication-oauth.yml가 없기 때문
```

## 3. 외부 Security 파일 등록하기

ClientRegistrationRepository를 생성하려면 clientId, clientSecret이 필수이다.

step1이 아닌 외부 디렉토리에 application-oauth.yml 파일을 생성해 보자.

(이후 step2, step3에서도 사용하기 위해서)

```bash
# 아래 명령어 입력 후 Local에 있는 application-oauth.yml 내용 복사
vim /home/ec2-user/app/application-oauth.yml
```

```bash
# deploy.sh 내용 수정
...
nohup java -jar \
	-Dspring.config.location=classpath:/application.yml,/home/ec2-user/app/
	application-oauth.yml \
	$REPOSITORY/$JAR_NAME 2>&1 &
```

-Dspring.config.location:

- 스프링 설정 파일 위치 지정
- 기본 옵션을 담고 있는 application.yml과 oauth 설정을 담고 있는 application-oauth.yml 위치를 지정
- application-oauth.yml은 절대경로를 사용한다. (외부에 파일이 있기 때문)

```bash
./deploy.sh # 다시 실행해서 확인해보기
```

## 4. 스프링 부트 프로젝트로 RDS 접근하기

- 현재 H2에서 자동 생성해주던 테이블을 MariaDB에 생성하기
- MariaDB에서 사용 가능한 드라이버를 프로젝트에 추가하기
- EC2 설정 : DB 정보는 중요하므로 EC2 서버 내부에서 접속 정보 관리하기

테스트 코드 수행시 발생하는 로그로 create table 하기 (posts, user)

스프링 세션 테이블은 IntelliJ에서 schema-mysql.sql 파일 확인해서 실행하기

```sql
CREATE TABLE posts (
	id bigint not null auto_increment,
	created_date datetime,
	modified_date datetime,
	author varchar(255),
	content TEXT not null,
	title varchar(500),
	primary key (id)
)ENGINE=InnoDB;

CREATE TABLE user (
	id bigint not null auto_increment,
	created_date datetime,
	modified_date datetime,
	email varchar(255) not null,
	name varchar(255) not null,
	picture varchar(255),
	role varchar(255),
	primary key (id)
)ENGINE=InnoDB;

CREATE TABLE SPRING_SESSION (
	PRIMARY_ID CHAR(36) NOT NULL,
	SESSION_ID CHAR(36) NOT NULL,
	CREATION_TIME BIGINT NOT NULL,
	LAST_ACCESS_TIME BIGINT NOT NULL,
	MAX_INACTIVE_INTERVAL INT NOT NULL,
	EXPIRY_TIME BIGINT NOT NULL,
	PRINCIPAL_NAME VARCHAR(100),
	CONSTRAINT SPRING_SESSION_PK PRIMARY KEY (PRIMARY_ID)
) ENGINE=InnoDB ROW_FORMAT=DYNAMIC;

CREATE UNIQUE INDEX SPRING_SESSION_IX1 ON SPRING_SESSION (SESSION_ID);
CREATE INDEX SPRING_SESSION_IX2 ON SPRING_SESSION (EXPIRY_TIME);
CREATE INDEX SPRING_SESSION_IX3 ON SPRING_SESSION (PRINCIPAL_NAME);

CREATE TABLE SPRING_SESSION_ATTRIBUTES (
	SESSION_PRIMARY_ID CHAR(36) NOT NULL,
	ATTRIBUTE_NAME VARCHAR(200) NOT NULL,
	ATTRIBUTE_BYTES BLOB NOT NULL,
	CONSTRAINT SPRING_SESSION_ATTRIBUTES_PK PRIMARY KEY (SESSION_PRIMARY_ID, ATTRIBUTE_NAME),
	CONSTRAINT SPRING_SESSION_ATTRIBUTES_FK FOREIGN KEY (SESSION_PRIMARY_ID) REFERENCES SPRING_SESSION(PRIMARY_ID) ON DELETE CASCADE
) ENGINE=InnoDB ROW_FORMAT=DYNAMIC;
```

```java
# build.gralde 의존성 추가
implementation("org.mariadb.jdbc:mariadb-java-client")
```

```yaml
# RDS 환경 profile 추가
spring:
  ...
  profiles:
    include: oauth,real-db
  ...
```

### EC2 설정

```bash
vim ~/app/application-real-db.yml # EC2 서버에 서버 정보 담을 yml 추가
```

```yaml
# application-real-db.yml
spring:
  jpa:
    hibernate: ddl-auto=none
  datasource:
    - url: jdbc:mariadb//rds주소:포트명/database이름
    - username: db계정
    - password: 계정 비밀번호
    - driver-class-name: org.mariadb.jdbc.Driver
```

ddl-auto=none:

- JPA로 테이블이 자동으로 생성되는 옵션을 None으로 지정
- RDS는 실제 운영 테이블이니 새로 만들지 않아야 함
- 이 옵션을 하지 않으면 테이블이 모두 새로 생성될 수 있음

```bash
# deploy.sh 내용 수정
...
nohup java -jar \
	-Dspring.config.location=classpath:/application.yml,/home/ec2-user/app/
	application-oauth.yml,/home/ec2-user/app/application-real-db.yml,classpath:
	/application-real.yml \
	-Dspring.profiles.active=real \
	$REPOSITORY/$JAR_NAME 2>&1 &
```

-Dspring.profiles.active=real:

- application-real.yml을 활성화 시킨다.
- application-real.yml의 spring.profiles.include=oauth, real-db 옵션 때문에 항상 real-db 도 활성화 된다.

```yaml
# application-real.yml
spring:
  jpa:
    properties:
      hibernate:
        - dialect: org.hibernate.dialect.MySQL57Dialect
        - dialect:
            storage_engine: innodb
  profiles:
    include: oauth,real-db
    session:
      store-type: jdbc
```

```bash
./deploy.sh # 재 실행
...
curl localhost:8080 # html 코드 확인
```

## 5. EC2에서 소셜 로그인하기

보안 그룹 변경 (8080 포트 안 열려 있으면 EC2 보안 그룹에 추가)

AWS EC2 도메인 접속 후 퍼블릭 DNS 확인

EC2 도메인 등록 (google, naver)
